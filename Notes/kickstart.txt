

Reprise a zero : 



=> 0xFC0B28 (InitResident)
Diff D5/D7 = 1...
FC4afc (expansion.library)	: 
FE4880 (potgo.resource)		: 
FE4FE4 (keymap.resource)	:
FC450C (cia.resource)		:
FC4794 (disk.resource)		: Ok
FE4774 (misc.resource)		: Ok 
FC5378 (graphics.library)	: 
( jusqu'a FCAC92 ok)
FE502E (keyboard.device)	: Ok => everything seems ok 
FE507A (gameport.device)	: 
FE90EC (timer.device)		: 
FC34CC (audio.device)		:
FE50C6 (input.device)		:
FE0D90 (layers.library)		: Ok => everything seems ok 
FE510E (console.device) 	: 
FE98E4 (trackdisk.device)	: (un décalage existe) 
      FEADF2 ?
=> FE63A6 ok (avec winuae)
=> FE5A2A ok (avec winuae)
=> FE631A ok (avec winuae)

FE55F2: cmp.w ($72,A6), D0        B0 6E 00 72  => DIFF : 4(moi)/ 9(winuae)
devrait avoir : 0000 0014 00FF 0000 00FD 0000 00FE 0000
j'ai 0000-0000
Ca se trouve ici : FE5822 => issue d'une interruption !
quand on remonte la stack :
FC4682
FC461C (On y passe !)
FC4620: move.b BFED01, D2         14 39 00 BF ED 01  => 0 au lieu de 188 ??
*** HANDLE ICR FROM CIA !!! ***
FE5822 (?) ($72, ...) : we should write some data here...
stack : FC461C 
BFED01 : lecture de 88 sur winuae 
Appel de la procedure qui va bien => (A2, 40-70)
(sur bit 8 = SP ?)
===> (passe-t-on vers FE998C ??) <===
CHGN : 0 = pas de changement ?!!!!

On passe dans FE9550 

FEA510 = DoIo dont on ne sort pas...

IORequest : 6096
IORequest.io_Message.mn_Node.ln_Succ = 0 (au lieu de quelque chose)
IORequest.io_Message.mn_Node.ln_Pred = 0 (au lieu de quelque chose)
IORequest.io_Message.mn_Node.ln_Type = 05 (devrait etre 07)
Cette IO Request, c'est le bloc 6038 décalé
FE9DA4 => 6096 est présent (dans le bloc 6010-) mais vide
FE9576=> Copie partielle !


FD3F5C (intuition.library)  : 
FC323A (alert.hook) 		: 
FE424C (mathffp.library)	: 
(FEB400) (workbench.task)
(FF425A) (dos)
FE8884 (strap.strap) 		: bloqué (init FE88D6 
end.

FE89C2: jsr ($FE38,A6)            			; DoIO qui ne sort pas...
L'IO request : ok.


FE8A02 => DoIO qui ne sort pas...
4694 : Device node
trackdisk.device : 

Task cree correctement 
FEAE50

Recherche de disque présent. Non.
=>FEADEE => jsr ($FFEE,A6)      return -1 OK !

Check : 
FC49A2: addq.b #1, ($126,A0)      
FC49A6: bset #$7, ($26,A6)        08 EE 00 07 00 26 
FC49AC: bne.s FC49BA  : Action sur Flags ??



Command2 = ; FEA734
FE5226 => On ne va pas dans le ReplyMsg
FE5EF4 = on y passe plusieurs fois 


###
A VERIFIER :
LSD/LSD2/ROd/ROD2 => Flags... 
CIA : effet CRA-TODIN ?
###

Erreur sur les affichages : 
Addresses de bitplanes incorrectes () et incrément sans limite = error !
DMACON fixé vers ici FCAF18
Copper list 2 fixée ici :FC6D00
Plus particulierement sur l'uinterrupt handler
FC6CDC


********************************
STRUCTURES
*********************
1F12 => ID lecteurs
unsigned int id_lecteur_0
unsigned int id_lecteur_1
unsigned int id_lecteur_2
 


;struct Node {
;    struct  Node *ln_Succ;	/* Pointer to next (successor) */
;    struct  Node *ln_Pred;	/* Pointer to previous (predecessor) */
;    UBYTE   ln_Type;
;    BYTE    ln_Pri;		/* Priority, for sorting */
;    char    *ln_Name;		/* ID string, null terminated */
;};
;struct MsgPort {
;    struct  Node mp_Node;
;    UBYTE   mp_Flags;
;    UBYTE   mp_SigBit;		/* signal bit number	*/
;    void   *mp_SigTask;		/* object to be signalled */
;    struct  List mp_MsgList;	/* message linked list	*/
;};
;
;struct Message {
;    struct  Node mn_Node;
;    struct  MsgPort *mn_ReplyPort;  /* message reply port */
;    UWORD   mn_Length;		    /* total message length, in bytes */
;				    /* (include the size of the Message */
;				    /* structure in the length) */
;};
;;struct IORequest {
;    struct  Message io_Message; (size = 14 + 4 + 2) = 20
;    struct  Device  *io_Device;     /* device node pointer  */ 4 
;    struct  Unit    *io_Unit;	    /* unit (driver private)*/ 4 
;    UWORD   io_Command;	    /* device command */ 2 
;    UBYTE   io_Flags; 1 
;    BYTE    io_Error;		    /* error or warning num */ 1 
;};28 bytes ( $1C)
*********************
********************************
*** HISTORIQUE 
********************************

*** FE6C2E: add.w #$FFD6, A1          ; => CA DOIT ETRE UNE SOUSTRACTION !!


AllocMem FC17EE : On a un pointeur null... ?? (==> voir 3e appel FD660A
A2 : ***5010*** => On a 0000 0000 0000 0676 00FC 07DC 00FC 07DE
     au lieu de : 0000 0000 001D 000A 0002 00FD 610A 0300
FD66DC: add.w D0, A0              calcul qui tronque FD !!?
*** Correction ADDA 


=> FC2DB4 ObtainSemaphore = attente sur 4d2a
Pq addq incorrect sur flags


=> Pb Console.device: (FE510E)
- RT_INIT : FE6B88 qui appelle Makelibrary
Le MakeLibrary ne sort jamais (relative vector FC1508)
Dans le Makelib = 
ok jusque FE6BA2
Command 9 pour DoIO , vers input.device
FE6C64: jsr ($FE38,A6)            ; DoIO  => Pas de retour....
*** PB : EOR INCORRECT !!


FCAC92 => recuperation d'une allocation.


(FC6D06 => Interrupt handler qui shunte la copperlist 2 ... ? normal ???
Stack : FC07F4  bsr.s     FC0828            Reserved vector #14.
semble ok)

FCAE68 => ??

Ensuite, coperlist/blitter...

**********************
Attention ! passage dans Alert( alertNum, parameters )
FC30EC
Appelé depuis FC3028 
Appelé depuis FE932C 15000002 Timer Device Bad supply
(0002 - Power supply: no 50/60 Hz ticks)=> OK
Causé par le CIA qui latchait incorrectement l'event sur MSB plutopt que LSB...
===> OK !
***********************

Guru meditation, pas de cause connue atm...
La stack du guru = 
	Wait / WaitIO / FE6C68 / ... /FE0000 / FC0680(FindNalme dans OpenDevice)
	==> stop qui repop sur interrupt causée par le blitter (FC6CDC)	
	=> Bricolage a FC6D04
===> OK !
	
********************
Detection du lecteur de disquette 
FC490A => voir MTR/READY etc
Sauvegarde de l'id du drive dans (A3)
004940: btst #5, BFE001           			Lecture bit READY
NE LIT PAS l'adresse BFE001... !
===> OK !
