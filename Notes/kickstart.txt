
Reprise a zero : 
=> 0xFC0B28 (InitResident)
=> Pb Console.device: (FE510E)
- RT_INIT : FE6B88 qui appelle Makelibrary
Le MakeLibrary ne sort jamais (relative vector FC1508)
Dans le Makelib = 
ok jusque FE6BA2
Command 9 pour DoIO , vers input.device
FE6C64: jsr ($FE38,A6)            ; DoIO  => Pas de retour....

14e init
input.device : Voir l'init... FE5F8E
=> PutMsg, FC1B9A (Signalk the task) seems ok
=> Lancement du vector de command FE51AC
=> FE61A6 (commande 9) qui clean juste le flags...

Retour au WaitIO, ..; Switch (pour donner la main a la tache réveillée ?)
on sort du wait, le signal est levé
FE6314
FE636E : OpenDevice "gameport.device" => No error
...
FE63D4 => Wait infini...
Il semble que la tache attendue n'existe pas : On switch toujours sur la même tache, la tache en cours. Vérifier 
- Que la tache est bien crée
- Qu'elle est bien endormie
TACHE input : 32d2
creation ok

Voir Reschedule : tout est bon... 
###
On lance bien la tache "input" : FE62D4 => A SUIVRE 
###





*********************
;struct Node {
;    struct  Node *ln_Succ;	/* Pointer to next (successor) */
;    struct  Node *ln_Pred;	/* Pointer to previous (predecessor) */
;    UBYTE   ln_Type;
;    BYTE    ln_Pri;		/* Priority, for sorting */
;    char    *ln_Name;		/* ID string, null terminated */
;};
;struct MsgPort {
;    struct  Node mp_Node;
;    UBYTE   mp_Flags;
;    UBYTE   mp_SigBit;		/* signal bit number	*/
;    void   *mp_SigTask;		/* object to be signalled */
;    struct  List mp_MsgList;	/* message linked list	*/
;};
;
;struct Message {
;    struct  Node mn_Node;
;    struct  MsgPort *mn_ReplyPort;  /* message reply port */
;    UWORD   mn_Length;		    /* total message length, in bytes */
;				    /* (include the size of the Message */
;				    /* structure in the length) */
;};
;;struct IORequest {
;    struct  Message io_Message; (size = 14 + 4 + 2) = 20
;    struct  Device  *io_Device;     /* device node pointer  */ 4 
;    struct  Unit    *io_Unit;	    /* unit (driver private)*/ 4 
;    UWORD   io_Command;	    /* device command */ 2 
;    UBYTE   io_Flags; 1 
;    BYTE    io_Error;		    /* error or warning num */ 1 
;};28 bytes ( $1C)
*********************
Erreur sur les affichages : 
Addresses de bitplanes incorrectes () et incrément sans limite = error !
DMACON fixé vers ici FCAF18
Copper list 2 fixée ici :FC6D00
Plus particulierement sur l'uinterrupt handler
FC6CDC

**************************
*** HISTORIQUE 
**************************
FCAC92 => recuperation d'une allocation.


(FC6D06 => Interrupt handler qui shunte la copperlist 2 ... ? normal ???
Stack : FC07F4  bsr.s     FC0828            Reserved vector #14.
semble ok)

FCAE68 => ??

Ensuite, coperlist/blitter...

**********************
Attention ! passage dans Alert( alertNum, parameters )
FC30EC
Appelé depuis FC3028 
Appelé depuis FE932C 15000002 Timer Device Bad supply
(0002 - Power supply: no 50/60 Hz ticks)=> OK
Causé par le CIA qui latchait incorrectement l'event sur MSB plutopt que LSB...
===> OK !
***********************

Guru meditation, pas de cause connue atm...
La stack du guru = 
	Wait / WaitIO / FE6C68 / ... /FE0000 / FC0680(FindNalme dans OpenDevice)
	==> stop qui repop sur interrupt causée par le blitter (FC6CDC)	
	=> Bricolage a FC6D04
===> OK !
	
********************
Detection du lecteur de disquette 
FC490A => voir MTR/READY etc
Sauvegarde de l'id du drive dans (A3)
004940: btst #5, BFE001           			Lecture bit READY
NE LIT PAS l'adresse BFE001... !
===> OK !
