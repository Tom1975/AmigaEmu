SYNCHRO LOGIQUE : 

Track buffer : 6a5c
*** Main thread
FE8A84 -> FE8A9A => Attente d'une disquette
FE89B0 => disk detecté
FE8A02 => CMD_READ => FEA734  ERROR 1B !
*** Trackdisk
FEA536 => Read command ?
FEA71A => End of track read : Int.
FEAFE2 => Load and read the track
FEA9CE
	FEAFE2 => 
	FEAFFC => FEAF4C 
	FEB094 => Decodage header ok (checksum puis amiga format )
	FEB0F0 = add total length to A0
	FEB180 = Info + checksum ok
	FEB1A8 = Checksum Data : 55014104 OK
	FEB1A8 => 3e secteur : Ko 50514050 / 41014511
		50514050  = 0101 0000 0101 0001 0100 0000 0101 0000
		41014511  = 0100 0001 0000 0001 0100 0101 0001 0001
Load 3e secteur : 
Checksum : base 0 		^ 0x552aa924 = 0x552aa924
			0x552aa924	^ 0x552aaaa9 = 0x0000038d
			0x0000038d  ^ 0x2aaaaaaa = 0x2aaaa927 ??
...
0xe9a9c793 & 0x55555555 = 41014511
0x8000038d		105
FEA9EA

###
A VERIFIER :
LSD/LSD2/ROd/ROD2 => Flags... 
CIA : effet CRA-TODIN ?
###
*** Checksum header 
	retour : D0 = 1b (TDERR_BadSecHdr)
==> AAAA AAAA 4489 4489 
==> Header : FF00000B => 11111111 00000000 00000000 00001011
	odd  : 1x1x1x1x 0x0x0x0x 0x0x0x0x 0x0x1x1x 
	=> 1111000000000011
	MFM :01010101 00101010 10101010 10100101
	=> 552A AAA5
	even : x1x1x1x1 x0x0x0x0 x0x0x0x0 x0x0x0x1 
	=> 1111000000000001
	MFM :  01010101 00101010 10101010 10101001
	=> 552A AA A9
==> Ecriture ok.
*** CHECKUM HEADER OK

*** agnus & timing
horizontal counter agnus : increment tous les ticks CCK (up)
227 CCK / line (908 pixel/line  ~ 70ns / pixel)
lores : 8 CCK = 16 pixels
hires : 4 CCK = 16 pixels

=> A faire :
- Quand 16 pixels sont prets (via bitplane) => Les envoyer à l'ecran.
Ca fera 16/32 pixels (hi/lo res).
- Ecran : Gestion d'une ligne / ecran par agnus (hsync/vsync).
Remplissage de cette ligne par bitplane/denise 


Fonctionnement de l'écran :
** Attention au test : 
Si ve > vp, return true.



*********************
********************************
*** HISTORIQUE 
********************************



Message du cia timer => FE643C ?
FE9824 => Ecriture du timer
FE9740 : Bouclage regulier... mais pas de retour au handler ?
Plus d'interrrupt...

Debut : FEA01C

***FEAE98 => GetMsg with a message. (port : 6038)

Message : 60BE :
;struct Message {
	mn_Node {
		ln_Succ = 00006050
		ln_Pred = 0000604c
		ln_Type = 0x07
		ln_Pri = 00
		ln_Name = FE98FE ("trackdisk.device")
	}
	mn_ReplyPort = 00006038
	length = 0000
}

Posté par ReplyMsg : 
STACK :
(
FE979E => CIA
)

==> Demande de timer faite par le trackdisk ???

FE9984 SendIO : ioRequest : 60BE
	struct IORequest
	{
		io_Message
		{
			mn_Node 
			{
				ln_Succ ; : 00006050
				ln_Pred : 604C
				lnType : 07
				lnPri : 0
				ln_Name : FE98FE ("trackdisk.device")
			}
			mn_ReplyPort : 6038
			mnLength : 0
		}
		io_Device : 00002ede
		io_unit : 00002f56
		io_command 0009
		io_flag : 0
		io_error : 0
	}
FEAF28

; Task trackdisk.device : Jamais reveillée !

FE99F4 : step

******************



=> Trackdisk.device = pas de reveil !
=> ; Handle ICR register from CIA-A  FC461C: movem.l D2/A2, -(SP)     = pas d'interrupt ?!
FC4620 : On passe bien ici avec D2 = 82 (CIA A t
TIMER B)


Timer : 
*****
***** FE9706 => On y passe !!! = ANALYSER ICI !!
9710 : 800 =>E4(EA)
FE9740 ok

FE97A2
00FE977C => A3+22h => pas la meme chose !
=>FE97EC (alors qu'on a fe9834 !)
...FE982C: move.b D0, BFE701         ; set TBLHI


**** Dessin Kickstart
FC55D2: movem.w ($24,A1), D2/D3 => D2ok, D3 ecrit tel un word.... ?
FC55D8: movem.w D0/D1, ($24,A1) => D0 ecrit ok, D1 shifted by 2 bytes => OK

**** Blocage dans trackdisk 

===> FE8B7E
FE8C74 ok
FCC722 ok
FCC7F0
FCC908
FCC97A
FCCA70
FC653A
FE8CCE

A5 = 18ba

FE8E42 => int a ce moment la (blitter)
==> Crash a la suite.

Crash ....
Illegal instruction + 
FE5CEE: jsr ($FFEE,A6)   => Go 19d8 ???
19d8 => jmp FE4996.
2d54 => gameport Device
Ecrasement ? Oui, a FC797x ...
index positioné a prealable :
FC7500: move.w #$FF18, D3
FC7508 => lsr.b => flag C correctement posé ?

FE8CCA => FCC6BA



FE8A02 => DoIO qui ne sort pas...
IORequest 18e6. 
mn_ReplyPort 1916
	flags : 0
	Sigbit : 1F
	SigTask : 1970 (exec ?)
Device 4694
Unit 6038
Command 02
flags 81
=> Reveille trackdisk a FEAE76
FEAE9A: bclr #$3, ($40,A3)        08 AB 00 03 00 40 
Le bit semble pas clear... => pas de disque ? (ou autre chose ??)
On continue : FEAF36 ok
FEA01C ok
bsr FE998C => C'est lui qui Signal (FC1E48)
FE99A2 => On recoit F0 (et nous : 3E.. ?)
=>FE99AC: btst #2, D2 pas identique => CHNG DOIT ETRE A 0 !!!!
FE9A08: bsr FEA4F0                 	; (Goto signal here !

On ne passe pas ici : FE9F92

4694 : Device node
trackdisk.device : 
Task cree correctement 
FEAE50
Recherche de disque présent. Non.
=>FEADEE => jsr ($FFEE,A6)      return -1 OK !

FC48FC : Detection des drives...
Task : FEAE50
###
=> FC0F54 STOP : Ok. 

###
FE55F2: cmp.w ($72,A6), D0        B0 6E 00 72  => DIFF : 4(moi)/ 9(winuae)
devrait avoir : 0000 0014 00FF 0000 00FD 0000 00FE 0000
j'ai 0000-0000
Ca se trouve ici : FE5822 => issue d'une interruption !
quand on remonte la stack :
FC4682
FC461C (On y passe !)
FC4620: move.b BFED01, D2         14 39 00 BF ED 01  => 0 au lieu de 188 ??
*** HANDLE ICR FROM CIA !!! ***
FE5822 (?) ($72, ...) : we should write some data here...
stack : FC461C 
BFED01 : lecture de 88 sur winuae 
Appel de la procedure qui va bien => (A2, 40-70)
(sur bit 8 = SP ?)
===> (passe-t-on vers FE998C ??) <===
CHGN : 0 = pas de changement ?!!!!

On passe dans FE9550 

FEA510 = DoIo dont on ne sort pas... OK
***IL MANQUAIT L'UPDATE DE ICR SUR TB/TA !

(    IORequest : 6096
IORequest.io_Message.mn_Node.ln_Succ = 0 (au lieu de quelque chose)
IORequest.io_Message.mn_Node.ln_Pred = 0 (au lieu de quelque chose)
IORequest.io_Message.mn_Node.ln_Type = 05 (devrait etre 07)
IORequest.io_Message.mn_ReplyPort = 60E6
mp_SigBit = 0A
SigTask = 6166 "trackdisk.device"
Device : 2EDE (Timer)
Unit : 2F08
command : 09
=> FE97EC, set TBLO/TBLHI a BB8
Le timer decremente et interrupt bien !
=> FC461C    )

*** FE6C2E: add.w #$FFD6, A1          ; => CA DOIT ETRE UNE SOUSTRACTION !!


AllocMem FC17EE : On a un pointeur null... ?? (==> voir 3e appel FD660A
A2 : ***5010*** => On a 0000 0000 0000 0676 00FC 07DC 00FC 07DE
     au lieu de : 0000 0000 001D 000A 0002 00FD 610A 0300
FD66DC: add.w D0, A0              calcul qui tronque FD !!?
*** Correction ADDA 


=> FC2DB4 ObtainSemaphore = attente sur 4d2a
Pq addq incorrect sur flags


=> Pb Console.device: (FE510E)
- RT_INIT : FE6B88 qui appelle Makelibrary
Le MakeLibrary ne sort jamais (relative vector FC1508)
Dans le Makelib = 
ok jusque FE6BA2
Command 9 pour DoIO , vers input.device
FE6C64: jsr ($FE38,A6)            ; DoIO  => Pas de retour....
*** PB : EOR INCORRECT !!


FCAC92 => recuperation d'une allocation.


(FC6D06 => Interrupt handler qui shunte la copperlist 2 ... ? normal ???
Stack : FC07F4  bsr.s     FC0828            Reserved vector #14.
semble ok)

FCAE68 => ??

Ensuite, coperlist/blitter...

**********************
Attention ! passage dans Alert( alertNum, parameters )
FC30EC
Appelé depuis FC3028 
Appelé depuis FE932C 15000002 Timer Device Bad supply
(0002 - Power supply: no 50/60 Hz ticks)=> OK
Causé par le CIA qui latchait incorrectement l'event sur MSB plutopt que LSB...
===> OK !
***********************

Guru meditation, pas de cause connue atm...
La stack du guru = 
	Wait / WaitIO / FE6C68 / ... /FE0000 / FC0680(FindNalme dans OpenDevice)
	==> stop qui repop sur interrupt causée par le blitter (FC6CDC)	
	=> Bricolage a FC6D04
===> OK !
	
********************
Detection du lecteur de disquette 
FC490A => voir MTR/READY etc
Sauvegarde de l'id du drive dans (A3)
004940: btst #5, BFE001           			Lecture bit READY
NE LIT PAS l'adresse BFE001... !
===> OK !

**************************
==> asl.l #0, D0 : ASL 8 !!!
