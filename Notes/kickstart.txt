SYNCHRO LOGIQUE : 


TRACK LOAD :

Chargement : (bp sur FEA8D6)
* 0; 0; 40; 71-1; 40-0; 57; 51-1; 54-0; 40; 50-1; 53-0
Taches en cours : 
WAIT:
- InitialCLI sp : d9e
- File System sp : 143e
- input.device sp : 42d8

Tache reveillée : FileSystem. (bp sur FC08B8)
2e fois - ... FFD996

3e fois : READY = Initial_CLI
Reveillée : FILE SYSTEM

Puis : InitialCli

FF44B4 =A5 (A3 ?)
FF44A8 =A6 (A4?)

- FF5946
- FF4B62
- FF4920 Allocmem
- FF6156
- FF5284
- FF87B0
- FF4924
- FF884C
- FF7126
- FF712C 
- FF7142
Deuxieme File system de lancé...
- FF58D8

-------
* trackdisk.device
FEA7E8 -> Sortie trackload (6a98)
			6a5c = out dma (debut)
FEACFA -> 	Mise en place blit 	
	63d8 : secteur en cours ?
	6038 + 49h = secteur total ?

RETOUR track 40 : FEA7E8 

Track buffer : 6a5c
*** Main thread--q
FE8A84 -> FE8A9A => Attente d'une disquette
FE89B0 => disk detecté
FE8A02 => CMD_READ => FEA734  ERROR 1B !
*** Trackdis-qk
FEA536 => Read command ?
FEA71A => End of track read : Int.
FEAFE2 => Load and read the track => OK
FEA7E8 => Sortie load track
FEA8C0 => FEACB2
FEA8D6 => Decode fait
*** Main thread

FE8A2C => Execute bootcode Ok
FE8B00 => FE8DD0 ok
FE8B38 => Jmp FF4290 : workbench.task !
FF4346 => ok
FF458C => ok
FF45B6 => ok
FF45EC => ok


Creation InitialCli
FF4774 : Start ok
FF48D6 : ok
FF490A => FF47C8
FF47D6 : ok
FF44B4 : ok
FF49C8 : ok
FF4A18 : => On sort alors qu'on devrait faire des boucles ?
CELA DIT : boucle créé ok
(not called)
FF4B40 Open dos library
FF439E PutMsg ??

Step en serie : (trackdisk)

Puis :

TRACK 40, lecture =>
Fin de lecture : 
FEA580
FEAFE2 
	FEAF4C
	FEB0B2...
	FEA8D6 = pas la meme chose !!
	destination : 6a58
	****** ERROR 1A = not enough sectors!  TDERR_TooFewSecs	=> change track/side = reset head counter ?!
	En sortie de FEA8D6 : not correct
FEAF3A



DoIO <- FEA514 <- FEA4E2 <- FEA44A <- FEA9B6 <- FEA7E8 <- FEA062
threads : 
* Initial CLI : FF44B2 ..... FF4A18 <- Wait.
* File System : FF4B6A .... FF47EC
* Validator : FF4B6A
* input device : 




###
A VERIFIER :
LSD/LSD2/ROd/ROD2 => Flags... 
CIA : effet CRA-TODIN ?
###
*** Checksum header 
	retour : D0 = 1b (TDERR_BadSecHdr)
==> AAAA AAAA 4489 4489 
==> Header : FF00000B => 11111111 00000000 00000000 00001011
	odd  : 1x1x1x1x 0x0x0x0x 0x0x0x0x 0x0x1x1x 
	=> 1111000000000011
	MFM :01010101 00101010 10101010 10100101
	=> 552A AAA5
	even : x1x1x1x1 x0x0x0x0 x0x0x0x0 x0x0x0x1 
	=> 1111000000000001
	MFM :  01010101 00101010 10101010 10101001
	=> 552A AA A9
==> Ecriture ok.
*** CHECKUM HEADER OK

*** agnus & timing
horizontal counter agnus : increment tous les ticks CCK (up)
227 CCK / line (908 pixel/line  ~ 70ns / pixel)
lores : 8 CCK = 16 pixels
hires : 4 CCK = 16 pixels

=> A faire :
- Quand 16 pixels sont prets (via bitplane) => Les envoyer à l'ecran.
Ca fera 16/32 pixels (hi/lo res).
- Ecran : Gestion d'une ligne / ecran par agnus (hsync/vsync).
Remplissage de cette ligne par bitplane/denise 


Fonctionnement de l'écran :
** Attention au test : 
Si ve > vp, return true.



*********************
********************************
*** HISTORIQUE 
********************************
FEACFA -> 	Mise en place blit 	
***	Source : A1 (639a => 00f298 au lieu de 6a5C !!
	element depuis FEA8D2 : A1 incorrect !
	FEA8A8 : On additionne des choses a A4... 
	FEA892: move.b ($49,A3), D0 => D0 = 20 !!! => 6081h !
	
	issue de Command 2 FEA762 => D1 = (3)20 !!! 
	FEA182 ?? (3e apres insertion disk)
	(FEA060 appel de command 2 ( D1 = 320 !!)
	FEA02C puis )
	
	FEA198: divu #$B, D0 => 370 pour d0 donne 3200050 (attendu 50) ?!!!!

Decodage MFM:
FEACDC => QBlit :  => Blit routine FEACF0
		Blit : bltcon0 1dd8 / bltcon1 0002
		FEB2CC => l/f mask + CDAT + MOD ABD
		FEAD22=> Lancement du blit !
Origine A =>  6C97
Origine B =>  6E97
C = 5555
Destination	D => 5D87
Operation : D8 => 1101 1000 => /ABC + A/B/C + AB/C + ABC
*****************


Message du cia timer => FE643C ?
FE9824 => Ecriture du timer
FE9740 : Bouclage regulier... mais pas de retour au handler ?
Plus d'interrrupt...

Debut : FEA01C

***FEAE98 => GetMsg with a message. (port : 6038)

Message : 60BE :
;struct Message {
	mn_Node {
		ln_Succ = 00006050
		ln_Pred = 0000604c
		ln_Type = 0x07
		ln_Pri = 00
		ln_Name = FE98FE ("trackdisk.device")
	}
	mn_ReplyPort = 00006038
	length = 0000
}

Posté par ReplyMsg : 
STACK :
(
FE979E => CIA
)

==> Demande de timer faite par le trackdisk ???

FE9984 SendIO : ioRequest : 60BE
	struct IORequest
	{
		io_Message
		{
			mn_Node 
			{
				ln_Succ ; : 00006050
				ln_Pred : 604C
				lnType : 07
				lnPri : 0
				ln_Name : FE98FE ("trackdisk.device")
			}
			mn_ReplyPort : 6038
			mnLength : 0
		}
		io_Device : 00002ede
		io_unit : 00002f56
		io_command 0009
		io_flag : 0
		io_error : 0
	}
FEAF28

; Task trackdisk.device : Jamais reveillée !

FE99F4 : step

******************



=> Trackdisk.device = pas de reveil !
=> ; Handle ICR register from CIA-A  FC461C: movem.l D2/A2, -(SP)     = pas d'interrupt ?!
FC4620 : On passe bien ici avec D2 = 82 (CIA A t
TIMER B)


Timer : 
*****
***** FE9706 => On y passe !!! = ANALYSER ICI !!
9710 : 800 =>E4(EA)
FE9740 ok

FE97A2
00FE977C => A3+22h => pas la meme chose !
=>FE97EC (alors qu'on a fe9834 !)
...FE982C: move.b D0, BFE701         ; set TBLHI


**** Dessin Kickstart
FC55D2: movem.w ($24,A1), D2/D3 => D2ok, D3 ecrit tel un word.... ?
FC55D8: movem.w D0/D1, ($24,A1) => D0 ecrit ok, D1 shifted by 2 bytes => OK

**** Blocage dans trackdisk 

===> FE8B7E
FE8C74 ok
FCC722 ok
FCC7F0
FCC908
FCC97A
FCCA70
FC653A
FE8CCE

A5 = 18ba

FE8E42 => int a ce moment la (blitter)
==> Crash a la suite.

Crash ....
Illegal instruction + 
FE5CEE: jsr ($FFEE,A6)   => Go 19d8 ???
19d8 => jmp FE4996.
2d54 => gameport Device
Ecrasement ? Oui, a FC797x ...
index positioné a prealable :
FC7500: move.w #$FF18, D3
FC7508 => lsr.b => flag C correctement posé ?

FE8CCA => FCC6BA



FE8A02 => DoIO qui ne sort pas...
IORequest 18e6. 
mn_ReplyPort 1916
	flags : 0
	Sigbit : 1F
	SigTask : 1970 (exec ?)
Device 4694
Unit 6038
Command 02
flags 81
=> Reveille trackdisk a FEAE76
FEAE9A: bclr #$3, ($40,A3)        08 AB 00 03 00 40 
Le bit semble pas clear... => pas de disque ? (ou autre chose ??)
On continue : FEAF36 ok
FEA01C ok
bsr FE998C => C'est lui qui Signal (FC1E48)
FE99A2 => On recoit F0 (et nous : 3E.. ?)
=>FE99AC: btst #2, D2 pas identique => CHNG DOIT ETRE A 0 !!!!
FE9A08: bsr FEA4F0                 	; (Goto signal here !

On ne passe pas ici : FE9F92

4694 : Device node
trackdisk.device : 
Task cree correctement 
FEAE50
Recherche de disque présent. Non.
=>FEADEE => jsr ($FFEE,A6)      return -1 OK !

FC48FC : Detection des drives...
Task : FEAE50
###
=> FC0F54 STOP : Ok. 

###
FE55F2: cmp.w ($72,A6), D0        B0 6E 00 72  => DIFF : 4(moi)/ 9(winuae)
devrait avoir : 0000 0014 00FF 0000 00FD 0000 00FE 0000
j'ai 0000-0000
Ca se trouve ici : FE5822 => issue d'une interruption !
quand on remonte la stack :
FC4682
FC461C (On y passe !)
FC4620: move.b BFED01, D2         14 39 00 BF ED 01  => 0 au lieu de 188 ??
*** HANDLE ICR FROM CIA !!! ***
FE5822 (?) ($72, ...) : we should write some data here...
stack : FC461C 
BFED01 : lecture de 88 sur winuae 
Appel de la procedure qui va bien => (A2, 40-70)
(sur bit 8 = SP ?)
===> (passe-t-on vers FE998C ??) <===
CHGN : 0 = pas de changement ?!!!!

On passe dans FE9550 

FEA510 = DoIo dont on ne sort pas... OK
***IL MANQUAIT L'UPDATE DE ICR SUR TB/TA !

(    IORequest : 6096
IORequest.io_Message.mn_Node.ln_Succ = 0 (au lieu de quelque chose)
IORequest.io_Message.mn_Node.ln_Pred = 0 (au lieu de quelque chose)
IORequest.io_Message.mn_Node.ln_Type = 05 (devrait etre 07)
IORequest.io_Message.mn_ReplyPort = 60E6
mp_SigBit = 0A
SigTask = 6166 "trackdisk.device"
Device : 2EDE (Timer)
Unit : 2F08
command : 09
=> FE97EC, set TBLO/TBLHI a BB8
Le timer decremente et interrupt bien !
=> FC461C    )

*** FE6C2E: add.w #$FFD6, A1          ; => CA DOIT ETRE UNE SOUSTRACTION !!


AllocMem FC17EE : On a un pointeur null... ?? (==> voir 3e appel FD660A
A2 : ***5010*** => On a 0000 0000 0000 0676 00FC 07DC 00FC 07DE
     au lieu de : 0000 0000 001D 000A 0002 00FD 610A 0300
FD66DC: add.w D0, A0              calcul qui tronque FD !!?
*** Correction ADDA 


=> FC2DB4 ObtainSemaphore = attente sur 4d2a
Pq addq incorrect sur flags


=> Pb Console.device: (FE510E)
- RT_INIT : FE6B88 qui appelle Makelibrary
Le MakeLibrary ne sort jamais (relative vector FC1508)
Dans le Makelib = 
ok jusque FE6BA2
Command 9 pour DoIO , vers input.device
FE6C64: jsr ($FE38,A6)            ; DoIO  => Pas de retour....
*** PB : EOR INCORRECT !!


FCAC92 => recuperation d'une allocation.


(FC6D06 => Interrupt handler qui shunte la copperlist 2 ... ? normal ???
Stack : FC07F4  bsr.s     FC0828            Reserved vector #14.
semble ok)

FCAE68 => ??

Ensuite, coperlist/blitter...

**********************
Attention ! passage dans Alert( alertNum, parameters )
FC30EC
Appelé depuis FC3028 
Appelé depuis FE932C 15000002 Timer Device Bad supply
(0002 - Power supply: no 50/60 Hz ticks)=> OK
Causé par le CIA qui latchait incorrectement l'event sur MSB plutopt que LSB...
===> OK !
***********************

Guru meditation, pas de cause connue atm...
La stack du guru = 
	Wait / WaitIO / FE6C68 / ... /FE0000 / FC0680(FindNalme dans OpenDevice)
	==> stop qui repop sur interrupt causée par le blitter (FC6CDC)	
	=> Bricolage a FC6D04
===> OK !
	
********************
Detection du lecteur de disquette 
FC490A => voir MTR/READY etc
Sauvegarde de l'id du drive dans (A3)
004940: btst #5, BFE001           			Lecture bit READY
NE LIT PAS l'adresse BFE001... !
===> OK !

**************************
==> asl.l #0, D0 : ASL 8 !!!
